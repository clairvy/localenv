* 近い内に解決すべき TODO

** skk.texi をなんとかする。拡張機能の説明を記述する。

* 変換モード

** 変換モード毎に異なる動作をするコマンド

例えば、skk-toggle-characters (`skk-toggle-kana'、`q' キーにバインド)
では、■モードでは、ひらがなモードとカタカナモードをトグルで変更し、
▽モードでは入力モードに変更を加えることなく、見出し語をひらがな <->
かたかなでトグルし、確定します。

このように変換モードの状態により異なる動作をするコマンドは SKK の中に
は沢山あります。これをもう少し統一的に書けないかな、とふと思いました。

** 変換領域の定義とその活用 (可能性の検討を要する)

** 「バッファに挿入する文字列」と「画面に表示する文字列」の区別

例えば変換モードでの「▽」や「▼」それに▼モードでの確定前の候補などは、
本来「表示すべきもの」ではあるが、「バッファに挿入すべき」ものでは必ず
しもない。これらを「表示するがバッファに挿入しない」実装にすることは
overlay を使えば可能ではある。こうすることで、余計な文字列をバッファに
挿入することに伴う undo 情報の乱れを防ぐこともできる。ただし、表示され
る column のズレなどを気にする場合もありうるので、まだ現在の実装から変
更する目途はたっていない。

また、これら "変換アンカー" を、別の文字 (記号) にしたり、色を付けたり、
画像使ってカスタマイズすることもアイデアとして示されている。

*** 複合語の入力支援

[http://mail.ring.gr.jp/skk/200512/msg00012.html]

* Hint from MSIME

** 手書き検索

ああいう機能欲しいよね...。実現困難か...。

(tomoe と連携する？)

** カスタマイズ

Emacs のカスタマイズはあまりかっこ良くないし、使いたい、という気になら
ないですね...。pySKK ではかっこ良くて使い易い GUI を提供したいもんです。
Emacs では改善の余地なし?

skk-cus は widget を使ってどの程度の UI を実現できるか示したもの。この
レベルでよければこれを拡張してもよい。

もうひとつの提案として、Emacs の menu の機能をそのまま使う方法もありう
る。これは最近の Emacs の Options メニューを見れば分かるように、
boolean や choice のカスタマイズ型なら任意のオプションを設定できる UI
である。この方法なら Emacs との親和性という意味でも問題ない。

さらに、実装ごとに設定ファイルを作る不便を改善するのがよい、という提案
がある。統合的デスクトップ環境においてはそれができればとても有効だと思
われる。ただし他の SKK variant の動向を見極めることも必要。

* 変換機能

** JIS コード変換

skk-kcode.el で JIS コードによる文字の選択ができるのだから，
skk-abbrev-mode で区点コードを文字に変換する機能があってもいいかもしれ
ない．

** 任意の外部コマンド検索機能

非公式には既に存在する。

** 複数辞書サーバ検索

複数のサーバに並行してアクセスできるようにすべきとのアイデアが示されて
いる。

間接的だが上記「任意の外部コマンド検索機能」を利用することでも可能。

** skk-search-prog-list の拡張

skk-search-prog-list の要素は現在、

 (skk-search-jisyo-file '("/usr/share/skk/SKK-JISYO.L" . euc-jp)
                        10000)

 (skk-search-server "/usr/share/skk/SKK-JISYO.L" 10000)

のように記述し、そのまま eval できる仕様になっている。もしこの設定を
plist をも許容して

 (file :file "/usr/share/skk/SKK-JISYO.L" :coding euc-jp :limit 10000)

 (server :host "localhost" :port 1178)

という指定を可能にできないか。この方法だと、複数サーバへの対応も自然な
形で実装できそう。

* 辞書の取り扱い

** アノテーションの仕様をもっと明確に策定し記述する

より良い注釈の付け方について議論し、辞書に反映させていくべき時期に来て
いるかもしれない。

 http://openlab.jp/skk/wiki/wiki.cgi?page=annotation

上記サイトにおいて annotation の規格化が図られている。
(ただし、これを L 辞書に適用する過程は恐らく機械化できないので、そのた
めに必要な労力が問題となる。)

** プログラム変換機能をどの SKK からも利用できるようにする

SKK は候補が S 式の場合にそれを評価したものを挿入できる。しかし現在、
SKK は elisp だけではないので、elisp 以外の共通語を用意するか、どの
SKK からも呼び出せるプログラムを用意するかしてプログラム変換機能を共有
できるようにすれば...

** 「この辞書からは学習しない」設定ができるとよい

** 「活用」の情報を利用した送りあり変換

[http://mail.ring.gr.jp/skk/200511/msg00006.html]

ユーザが「泣く」などの変換をした場合、 skk-henkan-okuri-strictly ない
しは skk-henkan-strict-okuri-precedence の環境下では送り仮名「く」が次
回変換から優先される。その際に、その他の活用形
(「泣か」「泣き」「泣い」「泣け」「泣こ」) の優先度も上げられたら便利
である、という提案がある。

これを実現するには

o あらかじめ動詞などの活用の情報を辞書などに埋めこんでおく
o ユーザの入力時に動的に、その単語のすべての活用形を推測する機能を実装
  する

という方法が考えられるが、後者はかなり大変だと思われる。幸い、
SKK-JISYO.notes が三田さんにより作製され、ここの送りありエントリにある
活用の情報を用いれば、前者の方法にて実装できるものと思われる。

注意点として、この機能が実装された場合にそれなりの副作用があることがあ
げられる。とくに種類の異なる品詞、ないしは異なる活用の種類をもつ同種の
品詞について、そのいずれかの活用形の優先度を下げてしまう場合があり、そ
れはユーザの好みと合わない可能性がある。

(例) 「泣く」を確定 → 「無き」「無い」などの優先度が下がる

現在の機能とこの新機能との公約数的機能が実装できれば都合がいいかもしれ
ないが、「原則的に単語変換」という制限の中では難しいものがある。結局、
ユーザオプションで新機能と旧来の機能を選択できるようにするのがいいのか
もしれない。

** 単語に「属性」のある辞書づくりとその利用

辞書の個々の見出し語、候補に属性を持たせる。それにより、例えば、次のよう
な機能を実装する。

1. その属性の内容により、変換の際に候補の絞り込み条件を指定できるよう
   にする。その際、絞り込み条件はユーザーの任意に変更できるようにする。
   一例をあげれば、サ変動詞になり得る名詞に適当な属性を持たせ、"〜する"
   という送り仮名が入力された場合には、そのサ変動詞属性を持った名詞の
   みを候補として出力する、など活用の幅は非常に広い。

2. 候補に最終の変換時刻などを属性として持たせ、辞書のメンテナンスに利
   用する(一定期間アクセスのない候補を個人辞書から削除するなど)。

3. 候補に関する意味を属性として持たせ、意味を調べるような拡張変換を行
   えるようにする。

言うは易しだが、色々な未解決の問題がある。多数の見出し語や候補に属性を
持たせて、通常の変換効率をできる限り落さないで、かつ効率良く属性のメン
テナンスを行う方法を模索することがまず大変。Emacs のバッファに読み込む
辞書とサーバ経由でアクセスしている辞書とがあることも検討事項。Emacs 側
の機能で対応した場合にサーバ経由の辞書属性をどうやって得るか、またはそ
の逆が課題である。コーディング抜きであってもアイディアをいただけたら幸
いである。

** 部首変換プログラムと辞書を作ること

** Canna や Wnn のサーバと接続して検索が可能になるようにする

すでに mecab-skkserv によって連文節変換をすること自体は可能になってい
る。また、tamago 4 に倣えば Canna、Wnn などのサーバとの通信は可能と考
えられる。


* コーディング

** Object Oriented programming 採用の可能性

FLIM (http://www.kanji.zinbun.kyoto-u.ac.jp/~tomo/elisp/FLIM/)
に含まれる luna という Emacs Lisp で Object Oriented programming を可能
にするプログラムがあります。著名どころでは、Wanderlust や Emacs-w3m の
Shimbun ライブラリが luna を利用しています。DDSKK は Emacs のバッファに
直接読み込む辞書、サーバ経由の辞書、Lookup とのゲートウェイによる辞書な
ど沢山の辞書があり、また、キーボード入力にも TUT-Code や NICOLA など色々
な種類をサポートしています。luna を利用することにより、これらのそれぞれ
の機能のために、それぞれ個別に書かれた処理を一元管理することができるよ
うになるのではないかと考えています。

** ユーザーオプションのバッファローカル化

いかなるユーザーオプション変数をバッファローカル化しても動作するように
すること。luna 化により解決する?

** APEL 依存性を見直す

最新の FSF Emacs の機能は整ってきているので、Emacs 21 以上は APEL 非依
存で動作し、それ以外では APEL を要求する、といった形態が望ましいだろう
か？

* ドキュメント

** 日本語版ドキュメントの整備

skk.texi の現行コードへの追従が間に合わない場合がある。

skk.texi の記述のうち、web を含めた他のドキュメントとの重複性はさらに
維持を難しくするので、URL への参照を利用することである程度解決している。

Texi 特有の維持のしにくさもあるので、SKK 辞書 Wiki も含めて維持しやす
い形に少しずつ転換していってもいいかもしれない。

skk.texi に一番要求されるのは、SKK の機能について詳細に解説すること。
この部分は他の形式ではなくて texi で維持し、育てていくべき。

** 英語版ドキュメントの整備

現在、チュートリアル以上のものがない。英語版の SKK マニュアルは、でき
ればあった方がいい。日本語を学ぶ人に役に立つこと、海外の人に有用な
free software であることを認識してもらうこと、などが目的。

ただし、日本語のドキュメントの整備すら十分できない状況で、現在のままの
人手だとそう簡単ではないと思われる。


* 報告された、または確認されているバグ (未修正)

** skk-henkan-show-candidates の数値変換有効時のバグ

http://mail.ring.gr.jp/skk/200602/msg00030.html

小畑さんからのご報告

> すっきりした対処法が分からなかったので ML に投げます。
> 
> 手元の環境で、/1 のように変換すると候補一覧表示状態でループになって
> しまいました。
> skk-search() や skk-henkan-list-filter() した結果として、その回での
> 表示対象 henkan-list が nil になると問題があるようです。
> 
> 一応再現用のコードをつけておきます。
> 
> ;; emacs -q として
> 
> (progn
> 
> (setq skk-init-file "")
> 
> ;(setq skk-show-annotation t)
> (setq skk-update-jisyo-function #'ignore)
> 
> (defun from-private ()
>   (skk-num-compute-henkan-key skk-henkan-key)
>   (if skk-use-numeric-conversion
>       (list "#4" "#2" "#5" "#1")
>     (list "一")))
> 
> (defun from-server ()
>   (if skk-use-numeric-conversion
>       (list "#1" "#3" "#2" "＃;number" "#0" "#4" "#5" "#9")
>     (list "１" "一" "壱;「一」の大字" "弌;「一」の異体字" "壹;「壱」の旧字" "ワン" "one")))
> 
> (defun from-eb ()
>   (unless skk-use-numeric-conversion
>     ;; from かなり古い通信用語の基礎知識
>     (list "Ｑ")))
> 
> (setq skk-search-prog-list
>       '((from-private)
> 	(from-server)
> 	(from-eb)))
> 
> )
> 
> ;; skk-search-server が追加されるので、
> ;; SKK 起動後に再度 skk-search-prog-list を設定しなおす

ものの見事に無限ループしている。確かに簡単に解決するのは難しいか。
henkan-list が nil のとき skk-henkan-list-filter() を呼ばないようにし
ただけだと、候補数が 7 ヶより少なくなってしまう。

** dcomp 候補複数表示時の face

skk-dcomp-show-multiple を t と設定し、実際に dcomp 候補を複数表示した
際に、現在は候補群の右側1カラムの face がデフォルトに戻ってしまう。

これは、補完候補が背景のテキストの face 属性を引き継ぐのを防ぐために、
故意に候補群の右側1カラムの face を剥ぎ取っている。

参考:
 [skk 6938] http://mail.ring.gr.jp/skk/200804/msg00019.html
 [skk 6941] http://mail.ring.gr.jp/skk/200804/msg00022.html

将来的にはもっとスマートな解決法が求められる。

* 一応解決済みの案件

** 同音異義語に対する意味のバルーン表示 (MSIME98 以降) [DONE]

漢字に弱いぼく (中島) としては絶対欲しい!  XEmacs と skk-lookup.el と
itimer.el があれば実現は比較的簡単 (itimer は、候補表示後一定期間入力
がないことをチェックするのに利用)?  バルーン表示は GNU Emacs では無理
かな。itimier.el の機能は GNU Emacs では?

あと、SKK では 4 番目までの候補は MSIME と異なりインライン表示されるが、
これらの意味はどうやって表示しましょ?

意味表示は skk-annotation で実現。バルーン表示は FSF Emacs については
tooltip の利用により実現された。

** On demand 意味表示

常に意味をバルーン表示するのは鬱陶しいと思う人もいるので、普段は off
にしておき、意味を知りたくなったときに on demand で表示する、という機
能はありうると思う。しかもこのようなやり方の場合、SKK の annotation に
拘る必要はなく、lookup や sdic など利用してもよいと思われる。

候補一覧における on demand 意味表示は三田さんにより実装されている．

** 候補の表示位置

標準では SKK の候補一覧表示はエコーエリアが使われる。最近の拡張で
window を分割してポップアップしたり、さらには Emacs の tooltip の機能
を使ってバルーン表示もできるようになった。

このバルーン表示は変換を実行している座標近くに候補が見えるため、眼球の
運動がごく少なくて済み、ユーザフレンドリーである。ただし tooltip は次
候補表示の際に tooltip frame を再構築するためやや重く、視覚的にもチラ
つきとして知覚されることがある。

2005 年になり uim.el が公開されたが、これは overlay の機能を用いて、使
用中の window 内に候補一覧をインライン表示することができる。この実装は
tooltip のように GUI に依存することなく同等の使用感を得られる点におい
て大変優れている。SKK においても実装される価値があるかもしれない。

インライン表示の機能 は Emacs 21 用に実装された (2005-10-05)。

** skk-undo-kakutei-word-only 下での undo 情報の喪失

http://mail.ring.gr.jp/skk/200503/msg00011.html

笠原＠九大さんからのご報告

> また別の、SKK にバッファの内容を喰われて undo で戻せない現象に当たった
> ので報告します。
> 
> 1) ある行で(うっかり)▽モードに入ってしまう
> 2) そのまま(気づかず)カーソルを下に数行移動
> 3) そこで気付いて(いつもの癖で) C-g を押すと、間の行が全部消えてしまう
> 
> 1)
> 1行目
> 2行目▽あ■←カーソル
> 3行目
> 4行目
> 5行目
> 
> 2)
> 1行目
> 2行目▽あ
> 3行目
> 4行目■←カーソル
> 5行目
> 
> 3)
> 1行目
> 2行目■←カーソル
> 5行目
> 
> 上方向への移動では起こりません。


本件に関する T の考え。 一応今回の件は skk-undo-kakutei-word-only が
non-nil の環境で

 1. keyboard-quit のあとの undo がおかしい
 2. skk-kakutei したあとの undo がおかしい

の 2点が問題。修正の方針を一応考えてみた。

 o keyboard-quit の際はまず skk-kakutei を呼んで
   skk-undo-kakutei-word-only の制御を脱してからその後の処理をする
 
   → 問題が単純化される。あとは 2 のみ解決すればよい
 
 o skk-kakutei の前に強制的に skk-previous-point に移動する
 
   → skk-undo-kakutei-word-only のときの変換領域制御
 
 o skk-set-henkan-point-subr が明示的に呼び出されたときは
   一時的に skk-undo-kakutei-word-only を nil に設定し、
   確定されたら non-nil に戻す
 
この変更をすると、以下の副作用が出る。

 o C-g で消えるのが ▽ から point 移動前の位置までに限定される。
   逆に point が前方に移動されていてもその範囲が消される。
 
 o ▽モードで何か入力しようとすると強制的にpoint 移動前の位置に移動
   させられる。
 
結局のところ、簡単にやろうとすると
 
 o skk-undo-kakutei-word-only のときは特に変換領域を想定し、undo の
   整合性のために変換領域以外の変更を禁止し、変換領域内の編集も変換
   領域の最後尾に限定する。
 
という仕様にしなければならない...?

変換領域の設定を本格的に考えなおせば、変換領域内の編集は自由にする
こともできると思うが...

本件に関しては、[skk 6524] の Obata さんのアイディア
> # skk-undo-kakutei-word-only は、変換中に buffer-undo-list を t にす
> # るのを止め、C-g したときは primitive-undo を、確定した時は
> # (delq nil buffer-undo-list) したものを退避しておいた内容とマージ、
> # みたいな事でうまくいかないかなと、最近考えていたり。
というアプローチで対策されました。



Local variables:
mode: outline
end:
